from PyQt5.QtWidgets import QApplication, QMainWindow, QWidget, QPushButton, QLabel
from PyQt5.QtGui import QPixmap
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import *
import cv2 as cv
import numpy as np
import random, os, sys

class ModelWindow(QWidget): # 모델 표시하는 창을 위해서 사용
    def __init__(self, model_img): # model_img를 받아서 img 표시
        super().__init__()
        self.setWindowTitle("모델 이미지")
        self.setGeometry(200, 200, 400, 400)

        label = QLabel(self) # 매칭 결과 label
        pixmap = QPixmap(model_img)

        self.match_label = QLabel() # 매칭 결과 QLabel
        label.setPixmap(pixmap)
        label.setAlignment(Qt.AlignCenter)
        
class Video(QMainWindow):
    def __init__(self) :
        super().__init__()
        self.setWindowTitle("Tangramplay")
        self.setGeometry(200,200,500,100)

        videoButton=QPushButton("ON",self)    
        captureButton=QPushButton("모델",self)
        matchButton=QPushButton("매칭",self)
        quitButton=QPushButton("나가기",self)
        
        videoButton.setGeometry(110,10,100,30)      
        captureButton.setGeometry(10,10,100,30)
        matchButton.setGeometry(210,10,100,30)
        quitButton.setGeometry(310,10,100,30)
        
        videoButton.clicked.connect(self.videoFunction) 
        captureButton.clicked.connect(self.captureFunction)         
        matchButton.clicked.connect(self.matchFunction)
        quitButton.clicked.connect(self.quitFunction)
        
        self.image_folder_path = "D:/python_workspace/tangramplay"

        self.load_img()

        self.model_window = None
        self.sift = cv.xfeatures2d.SIFT_create()

    def load_img(self): # tempimg 부름
        self.template_img = []
        for filename in os.listdir(self.image_folder_path):
            if filename.endswith(".png") or filename.endswith(".jpg"):
                img_path = os.path.join(self.image_folder_path, filename)
                self.template_img.append(img_path)
                
    def captureFunction(self): # 랜덤으로 모델 부름
        if self.model_window:
            self.model_window.close()
        random_img = random.choice(self.template_img) # 랜덤 검증 이미지 선택
        self.model_window = ModelWindow(random_img)
        self.model_window.show()
        
    def videoFunction(self): # ON
        self.cap=cv.VideoCapture(0,cv.CAP_DSHOW)
        if not self.cap.isOpened(): self.close()
            
        while True:
            ret,self.frame=self.cap.read() 
            if not ret: break            
            cv.imshow("display",self.frame)
            cv.waitKey(1)
        
    def matchFunction(self):       
        if not self.model_window:
            print("모델 이미지 선택")
            return
        
        model_img = cv.imread(self.template_img[0]) # 모델 이미지
        gray1=cv.cvtColor(model_img,cv.COLOR_BGR2GRAY)
        kp1, des1 = self.sift.detectAndCompute(gray1, None)

        gray2=cv.cvtColor(self.frame,cv.COLOR_BGR2GRAY)
        kp2, des2 = self.sift.detectAndCompute(gray2, None)

        flann_matcher=cv.DescriptorMatcher_create(cv.DescriptorMatcher_FLANNBASED)

        knn_match=flann_matcher.knnMatch(des1, des2, 2)

        T = 0.8
        good_match = []
        for nearest1, nearest2 in knn_match:
            if(nearest1.distance / nearest2.distance) < T:
                good_match.append(nearest1)

        if len(good_match) > 10: # 매칭된 특징점이 충분히 많을 때 조정해야 할듯
            src_pts = np.float32([kp1[m.queryIdx].pt for m in good_match]).reshape(-1, 1, 2)
            dst_pts = np.float32([kp2[m.trainIdx].pt for m in good_match]).reshape(-1, 1, 2)

            M, mask = cv.findHomography(src_pts, dst_pts, cv.RANSAC, 5.0)

            h, w = model_img.shape[:2]
            pts = np.float32([[0, 0], [0, h - 1], [w - 1, h - 1], [w - 1, 0]]).reshape(-1, 1, 2)

            dst = cv.perspectiveTransform(pts, M)

            self.frame = cv.polylines(self.frame, [np.int32(dst)], True, (255, 0, 0), 3, cv.LINE_AA)
            cv.imshow("display", self.frame)
            cv.waitKey(1)

            match_ratio = len(good_match) / len(knn_match)
            accuracy = match_ratio * 100
            print(f"정답 : {accuracy}%")
        else:
            print(f"오답 : {accuracy}%")
        
    def quitFunction(self):
        self.cap.release()
        cv.destroyAllWindows()
        self.close()
                
app=QApplication(sys.argv) 
win=Video() 
win.show()
app.exec_()
